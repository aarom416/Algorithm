import sys

input = sys.stdin.readline
n,k = map(int,input().split())

a,b = 0,n
# B로만 이루어진 문자열에서 앞에서 연속으로 A 로 바꾸면서 조건을 만족하는 경우의 최대를 구할 수 있음
# k 값을 넘지 않으면서 각 최대로 만들 수 있는 A-B 꼴 구함.
# n = 10, k = 12 -> a = 2, b = 8 => AABBBBBBBB 2*8 = 16 개 경우가 생기지만 제일 오른쪽 A를 움직여 갯수 줄여나가면됨
while a*b<k and b>0:
    a+=1
    b-=1
# k = 0 이면 모두 B 이면 됨
if k==0:
    print('B'*n)
    exit()
# b = 0 이면 만들 수 없음 최대로 곱했는데도 k 값을 못 넘겼다는 의미
elif b==0:
    print(-1)
    exit()
#AABBBBBBBB 의 경우 제일 오른쪽에 있는 A 를 제외한 나머지 A 들로 만들 수 있는 경우를 다 구해서 남은 경우(12-8=4) 확인
remain = k-(a-1)*b

#이제 제일 오른쪽에 있는 A만 옮겨서 만들면 됨
#제일 오른쪽에 있는 A를 제외한 앞에 A들에 대해서는 a-1 개 만큼 앞에 쌓아주고 (제일 맨뒤 A를 제외한 나머지 A들이 만들 수 있는 경우의 수는 알아서 고정됨)
#B도 B의 개수에서 남은 경우를 뺀거 만큼 뒤에 붙혀줌 (빼줘야 맨뒤에 남은 경우만큼 B를 붙혀 최종적으로 개수 맞출 수 있음)
#a-1 개 만큼 앞에서 붙혔으니 나머지 A 하나 붙혀 A 끝냄
#B도 나머지 개수 만큼 B를 붙혀 최종 마무리 -> 결국 앞에서 A 하나 빼고 최대한 맞춰주고 나머지 경우를 A 하나와 B로 맞춰준다는 의미
print('A' * (a - 1) + 'B' * (b - remain) + 'A' + 'B' * remain)
